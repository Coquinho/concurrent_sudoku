\documentclass[a4paper, 12pt]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{fontspec}
\usepackage[urlcolor=blue, linkcolor=black, colorlinks=true]{hyperref}
\usepackage{fancyvrb}
\usepackage{geometry}
\usepackage{minted}
\usepackage{amsmath}

\geometry{
    a4paper,
    left = 20mm,
    right = 20mm,
    top = 20mm,
}

\begin{document}
\begin{titlepage}
    \begin{center}
        \huge{Universidade Federal de Santa Catarina}

        \vspace{10pt}

        \vspace{85pt}

        \textbf{\LARGE{Sistemas Operacionais I}}
        \large{\\Trabalho 1}
        \vspace{160pt}

    \end{center}

    \begin{flushleft}
        \begin{tabbing}
            Alunos\qquad\qquad\=
            Filipe Oliveira de Borba\\
            \>Guilherme Christopher Michaelsen Cardoso\\
            \>Lucas Cavalcante Sousa\\\\
            Professor\> Márcio Bastos Castro \\
        \end{tabbing}
    \end{flushleft}

    \begin{center}
        \vspace{\fill}
        Florianópolis, \today
    \end{center}
\end{titlepage}


\newpage
\tableofcontents
\thispagestyle{empty}


\newpage
\pagenumbering{arabic}

\section{Sudoku}
O Sudoku é um quebra-cabeça de disposição de números. O quebra-cabeça é 
representado por uma matriz quadradra de ordem 9, composta de submatrizes de 
ordem 3 chamadas blocos ou regiões. Para resolver, cada uma das 81 células 
devem ser preenchidas com números de 1 à 9, de forma que cada uma das linhas, 
colunas e regiões contenha cada um dos números possíveis. Um Sudoku 9x9, então, 
está correto quando os números de 1 à 9 estão preenchendo todos as células da 
matriz de forma a não haver nenhuma repetição nas linhas, colunas nem regiões.
De forma geral pode-se construir um quebra-cabeça baseado em matrizes 
$n^2 \times n^2$.

\section{Verificando a Solução de um Sudoku}

Verificar a solução de um Sudoku consiste em checar a existência de números
repetidos em todas as linhas, colunas e regiões. Para checar uma linha,
a estratégia utilizada foi utilizar um \textit{bitfield} \textit{flag}, onde o 
bit na posição \textit{X} de \textit{flag} deve estar no valor lógico 1 quando 
o número \textit{X} está presente naquela linha.
A cada número lido da linha, a sua posição correspondente em \textit{flag} é
marcada através de um ou lógico entre a \textit{flag} e 1 deslocado à esquerda
o número encontrado de vezes, de forma a indicar que o número foi visto.
Ao final da linha o valor de \textit{flag} deve ser igual a 0x03FE, ou seja, 
todos os números de 1 à 9 foram encontrados, caso contrário um erro deve ser
apontado naquela linha. Note que se um número já encontrado é lido novamente, o 
bit na posição relativa àquele número volta a ser 0 e o teste falhará. Mesmo no 
caso de um terceiro número repetido, ao menos dois dos outros números estarão 
faltando e o teste falhará.

\begin{minted}[mathescape,
                numbersep=3pt,
                gobble=1,
                fontsize=\small,
                framesep=2mm]{c}

    /* checks row correctness */
    int check_row(int id, int row)
    {
        int flag = 0x0;
        for (int i = 0; i < SIZE; i++)
            flag |= 1 << puzzle[row][i];

        if (flag == 0x03FE) /* 0x03FE means all numbers from 1 to 9 are present */
            return 0;

        printf("Thread %d: Erro na linha %d\n", id, row + 1);
        return 1;
    }

\end{minted}


O princípio usado para verificar colunas e regiões é o mesmo. Porém a forma de 
iterar sobre os elementos é diferente. Nas regiões é necessário obeter linha e 
coluna do primeiro elemento, que são dados pelos expressões 
\textit{(region / region\_sz) * region\_sz} para obter a linha e
\textit{(region \% region\_sz) * region\_sz} para obter a coluna, onde 
\textit{region_sz} é a ordem da região (3 no caso de um Sudoku normal). A uso 
de uma expressão para calcular a ordem da região é motivado pela possibilidade 
de extensão para quebra-cabeças de tamanhos maiores.

\begin{minted}[mathescape,
                numbersep=3pt,
                gobble=1,
                fontsize=\small,
                framesep=2mm]{c}

    /* checks region correctness */
    int check_region(int id, int region)
    {
        int flag = 0x0;

        /* calculates region's first element row and column */
        int region_sz = (int) sqrt(SIZE);
        int si = (region / region_sz) * region_sz;
        int sj = (region % region_sz) * region_sz;

        for (int i = 0; i < region_sz; i++) {
            for (int j = 0; j < region_sz; j++)
                flag |= 1 << puzzle[si + i][sj + j];
        }

        if (flag == 0x03FE) /* 0x03FE means all numbers from 1 to 9 are present */
            return 0;

        printf("Thread %d: Erro na regiao %d\n", id, region + 1);
        return 1;
    }

\end{minted}


\section{Abordagem paralela}
A verificação de um Sudoku pode ser vista como a verificação de suas linhas,
colunas e regiões, ou seja, podemos dividir o problema em 27 problemas menores,
checar uma linha, uma coluna ou uma região.
Essa divisão pode ser atingida pelo cálculo \textit{load = (SIZE * 3) / nthreads} e
\textit{rest = (SIZE * 3)}, onde cada thread realizará no mínimo \textit{load} 
tarefas, sendo que as \textit{rest} primeiras realizarão \textit{load} + 1.
\par
Além disso existem 3 tipos de tarefas: linhas - tipo 0 -, colunas - tipo 1-  e
regiões - tipo 2-. Os tipos são obtidos pelo cálculo \textit{job\_type = i / 9}
onde \textit{i} é o número da tarefa. Dentro de cada tipo existem 9 tarefas, 
referentes linhas, colunas e regiões. As linhas, por exemplo, são numeradas de 
0 à 8. O mesmo pode ser observado com as colunas e regiões. A tarefa pode ser 
obtida pelo cálculo \textit{where = i \% 9}.
\par
Desta forma a tarefa 22, é do tipo 2, ou seja. região, e consiste em verificar
a 4 região.


\section{Uso}

A verificação do Sudoku inserido pelo usuário pode ser feito pela linha de comando:
\begin{verbatim}
./sudoku <grid para verificação> <número de threads>
\end{verbatim}

Exemplo de execução correta do programa:

\begin{verbatim}

./sudoku input_grid_correto.txt 4
Quebra-cabecas fornecido:
5 3 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 3
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 9
Erros encontrados: 0
\end{verbatim}

Exemplo de execução incorreta do programa:

\begin{verbatim}
./sudoku input_grid_errado.txt 4
Quebra-cabecas fornecido:
3 5 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 7
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 8
Thread 1: Erro na linha 4
Thread 2: Erro na linha 9
Thread 2: Erro na coluna 1
Thread 2: Erro na coluna 2
Thread 4: Erro na regiao 6
Thread 4: Erro na regiao 9
Thread 3: Erro na coluna 9
Erros encontrados: 7
\end{verbatim}

É possível perceber que, no primeiro caso a solução fornecida não infringe
nenhuma das regra do sudoku. Porém, no segundo caso, temos 7 erros, 3 em
colunas, 2 em linhas e 2 em regiões da solução dada.

\section{Considerações Finais}
Dado que o problema não é escalável, ou seja, possui um tamanho fixo, e é um
problema pequeno, e consequentemente o número de threads "necessárias" também é 
pequeno. O \textit{overhead} na utilização de mais threads que o necessário é 
substancial, de forma que a solução paralela não obtém resultados expressivos 
e comparação com a solução sequencial em termos de tempo de execução.


\end{document}
